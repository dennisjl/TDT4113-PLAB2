import os, sys          #dealing with filename
from math import log
import collections


class Reader():

    stopwords=open("C:/Users/Dennis/Downloads/data(2)/data/stop_words.txt").read().split()

    def __init__(self,path,n_gram,prune):
        self.path = path
        self.n_gram = n_gram                          #part 6, build ngrams/bigrams, aka building phrases
        self.prune = prune/100                        #part 5, clears up words that not used in 1% of all docs
        self.docs = 0
        self.cdic = collections.defaultdict(int)
        self.dic = collections.defaultdict(int)

    def read(self):
        dirs = os.listdir(self.path)
        for doc in dirs:
            self.docs += 1
            text = open(self.path+"/"+doc,encoding='UTF-8').read().replace('/',' ')                               #removing / to distinguish numbers, given in part 1
            temptext = ''.join([c.lower() for c in text if c.isalpha() or c.isspace() or c.isdigit()]).split()
            #temptext is now only consisting of digits, letters and spaces

            for i in range(len(temptext)-self.n_gram):
                temptext.append('_'.join(temptext[i:self.n_gram+i]))
            temptext = set(x for x in temptext if x not in self.stopwords)                      #uses stopword to filter out the words in doc stopwords
            #temptext is now unique words from each text combined with n_grams
            #test med å kjøre temtext - words senere

            for word in temptext:
                self.cdic[word] += 1
            #self.cdic now contains occurence of each word


    def analyze(self,other):
        totaldocs = self.docs+other.docs
        sdic = collections.defaultdict(int)
        allwords = set(list(self.cdic.keys()) + list(other.cdic.keys()))

        for key in allwords:
            own_sum = self.cdic[key]
            other_sum = other.cdic[key]
            rest = own_sum + other_sum
            if rest > self.prune * totaldocs:
                try:
                    self.dic[key] = log(own_sum / rest)
                except ValueError:
                    self.dic[key] = log(0.01)
        print(sorted(self.dic.items(), key= lambda x: x[1], reverse=True)[:50])
        #will now print the 25 most informative words for positive and negative reviews, + the value of the numberes, generated by the using the logaryth, as suggested in part 7. (lambda returns sum of the two arguments


class Tester():

    stopwords=open("C:/Users/Dennis/Downloads/data(2)/data/stop_words.txt").read().split()

    def __init__(self,posreader,negreader,n_gram):
        self.posreader = posreader
        self.negreader = negreader
        self.n_gram = n_gram

    def classify(self,path,group):              #part 4, assigning informationvalue
        ptot,ntot,tot,=0,0,0,
        dirs = os.listdir(path)
        neg_val = sum(val for val in self.negreader.dic.values())
        pos_val = sum(val for val in self.posreader.dic.values())
        balancer = neg_val / pos_val  # Balances the lists, to give more accurate results

        for doc in dirs:
            tot += 1
            pval,nval = 0,0
            text=open(path+'/'+doc, encoding='UTF-8').read().replace('/',' ') #removing / to distinguish numbers
            temptext = ''.join([c.lower() for c in text if c.isalpha() or c.isspace() or c.isdigit()]).split()
            #temptext is now only consisting of digits, letters and spaces

            for i in range(len(temptext)-self.n_gram):
                temptext.append('_'.join(temptext[i:self.n_gram+i]))
            #added n_grams and removed duplicates

            temptext = set(x for x in temptext if x not in self.stopwords)
            for word in temptext:
                pval += self.posreader.dic[word]
                nval += self.negreader.dic[word]
            pval*=balancer
            if nval>pval:
                ntot += 1
            else:
                ptot += 1
        if group == "neg":
            print("neg ", 100*ntot/tot,"%",sep="")
        elif group == "pos":
            print("pos ", 100*ptot/tot,"%",sep="")

